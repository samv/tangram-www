<!--#set var="title" value="Documentation: Tangram::Storage"-->
<!--#include virtual="/header.html"-->
<a class="POD_NAVLINK" name="Pod_TOP_OF_PAGE"></a>
<h1 class="POD_TITLE">Tangram::Storage</h1>
<hr>
<ul>
<li><a class="POD_NAVLINK" href="#NAME">NAME</a>
<li><a class="POD_NAVLINK" href="#SYNOPSIS">SYNOPSIS</a>
<li><a class="POD_NAVLINK" href="#DESCRIPTION">DESCRIPTION</a>
<li><a class="POD_NAVLINK" href="#MEMORY_MANAGEMENT">MEMORY MANAGEMENT</a>
<li><a class="POD_NAVLINK" href="#INTERNAL_CONNECTION">INTERNAL CONNECTION</a>
<li><a class="POD_NAVLINK" href="#CLASS_METHODS">CLASS METHODS</a>
<ul>
<li><a class="POD_NAVLINK" href="#connect">connect</a>
</ul>
<li><a class="POD_NAVLINK" href="#INSTANCE_METHODS">INSTANCE METHODS</a>
<ul>
<li><a class="POD_NAVLINK" href="#insert">insert</a>
<li><a class="POD_NAVLINK" href="#update">update</a>
<li><a class="POD_NAVLINK" href="#id">id</a>
<li><a class="POD_NAVLINK" href="#load">load</a>
<li><a class="POD_NAVLINK" href="#remote">remote</a>
<li><a class="POD_NAVLINK" href="#select">select</a>
<li><a class="POD_NAVLINK" href="#cursor">cursor</a>
<li><a class="POD_NAVLINK" href="#erase">erase</a>
<li><a class="POD_NAVLINK" href="#tx_start">tx_start</a>
<li><a class="POD_NAVLINK" href="#tx_commit">tx_commit</a>
<li><a class="POD_NAVLINK" href="#tx_rollback">tx_rollback</a>
<li><a class="POD_NAVLINK" href="#tx_do">tx_do</a>
<li><a class="POD_NAVLINK" href="#unload">unload</a>
<li><a class="POD_NAVLINK" href="#disconnect">disconnect</a>
</ul>
</ul>
<hr>
<h2 class="POD_HEAD1"><a name="NAME">NAME</a></h2>
<p class="POD_TEXT">
Tangram::Storage - persistent object database
</p>
<h2 class="POD_HEAD1"><a name="SYNOPSIS">SYNOPSIS</a></h2>
<pre class="POD_VERBATIM">
   use Tangram;

   $storage = Tangram::Storage-&gt;connect( $schema,
      $data_source, $username, $password );

   $oid = $storage-&gt;insert( $obj );
   @oids = $storage-&gt;insert( @objs );

   $storage-&gt;update( $obj );
   $storage-&gt;update( @objs );

   $obj = $storage-&gt;load( $oid );
   @objs = $storage-&gt;load( @oids );

   @objs = $storage-&gt;select( $class );
   @objs = $storage-&gt;select( $remote, $filter );

   $cursor = $storage-&gt;cursor( $remote, $filter );

   $storage-&gt;disconnect();
</pre>
<h2 class="POD_HEAD1"><a name="DESCRIPTION">DESCRIPTION</a></h2>
<p class="POD_TEXT">
A Tangram::Storage object is a connection to a database configured for
use with Tangram.
</p>
<h2 class="POD_HEAD1"><a name="MEMORY_MANAGEMENT">MEMORY MANAGEMENT</a></h2>
<p class="POD_TEXT">
Starting with version 1.18, Tangram attempts to use the support for
weak reference that was introduced in Perl 5.6. Whether that support
is found or not has a major impact on how Storage influences object
lifetime.
</p>
<p class="POD_TEXT">
If weakref support <i>is</i> available, Storage uses weak references
to keep track of objects that have already been loaded. This does
<i>not</i> prevent the objects from being reclaimed by Perl. IOW, the
<i>client</i> code decides how long an object remains in memory.
</p>
<p class="POD_TEXT">
If weakref support <i>is not</i> available, Storage uses normal, 'strong'
references. Storage will pin in memory all the objects that have been loaded
<i>and</i> inserted through it, until you call the section on <a class="POD_LINK" href="#disconnect">disconnect</a> elsewhere in this document or
the section on <a class="POD_LINK" href="#unload">unload</a> elsewhere in this document.
</p>
<p class="POD_TEXT">
In either case, Tangram will <i>not</i> break circular structures for you.
</p>
<h2 class="POD_HEAD1"><a name="INTERNAL_CONNECTION">INTERNAL CONNECTION</a></h2>
<p class="POD_TEXT">
Except in the implementation of cursor(), Tangram uses a single DBI connection in its operations.
That connection is called the 'internal' connection. Since, in general, database managers
do not allow multiple result sets on the same connection, the internal connection can be used
only to carray a single task at a time.
</p>
<p class="POD_TEXT">
the <a class="POD_LINK" href="../Tangram/Cursor.html">Tangram::Cursor</a> manpages returned by cursor() do not suffer from this limitation
because they use a separate DBI connection.
</p>
<h2 class="POD_HEAD1"><a name="CLASS_METHODS">CLASS METHODS</a></h2>
<h3 class="POD_HEAD2"><a name="connect">connect</a></h3>
<pre class="POD_VERBATIM">
   $storage = connect( $schema,
      $data_source, $username, $auth, \%options )
</pre>
<p class="POD_TEXT">
Connects to a storage and return a handle object. Dies in case of failure.
</p>
<p class="POD_TEXT">
$schema is an the <a class="POD_LINK" href="../Tangram/Schema.html">Tangram::Schema</a> manpage object consistent with the database.
</p>
<p class="POD_TEXT">
$data_source, $username and $auth are passed directly to
DBI::connect().
</p>
<p class="POD_TEXT">
\%options is a reference to a hash that may contain the following
fields:
</p>
<ul class="POD_LIST">
<li class="POD_ITEM"><a name="dbh"><p>dbh</p></a>
</ul>
<p class="POD_TEXT">
All fields are optional.
</p>
<p class="POD_TEXT">
<code>dbh</code> can be used to connect a Storage via an existing DBI
handle. $data_source, $username and $auth are still needed because
Tangram may need to open extra connections (see below).
</p>
<h2 class="POD_HEAD1"><a name="INSTANCE_METHODS">INSTANCE METHODS</a></h2>
<h3 class="POD_HEAD2"><a name="insert">insert</a></h3>
<pre class="POD_VERBATIM">
   $storage-&gt;insert( @objs );
</pre>
<p class="POD_TEXT">
Inserts objects in storage. Returns the ID(s) assigned to the object(s).
This method is valid in both the <u>scalar and list contexts</u> entry elsewhere in this document.
</p>
<p class="POD_TEXT">
The inserted objects must be of a class described in the schema associated to the storage.
</p>
<p class="POD_TEXT">
Attempting to insert an object that is already persistent in the storage is an error.
</p>
<p class="POD_TEXT">
Tangram will automatically insert any object that is refered by $obj if it is not
already present in storage. In the following example:
</p>
<pre class="POD_VERBATIM">
   my $homer = NaturalPerson-&gt;new(
      firstName =&gt; 'Homer', name =&gt; 'Simpson',
      children =&gt; Set::Object-&gt;new(
         NaturalPerson-&gt;new(
            firstName =&gt; 'Bart', name =&gt; 'Simpson' ),
         NaturalPerson-&gt;new(
            firstName =&gt; 'Lisa', name =&gt; 'Simpson' ),
         NaturalPerson-&gt;new(
            firstName =&gt; 'Maggie', name =&gt; 'Simpson'
      ) ) );

   $storage-&gt;insert( $homer );
</pre>
<p class="POD_TEXT">
...Tangram automatically inserts the kids along with Homer.
</p>
<h3 class="POD_HEAD2"><a name="update">update</a></h3>
<pre class="POD_VERBATIM">
   $storage-&gt;update( @objs );
</pre>
<p class="POD_TEXT">
Save objects to storage.
This method is valid in both the <u>scalar and list contexts</u> entry elsewhere in this document.
</p>
<p class="POD_TEXT">
The objects must be of a class described in the schema associated to the storage.
</p>
<p class="POD_TEXT">
Attempting to update an object that is not already present in the storage is an error.
</p>
<p class="POD_TEXT">
Tangram will automatically insert any object that is refered by an inserted object if it is not
already present in storage. It will not automatically update the refered objects that are already
stored. In the following example:
</p>
<pre class="POD_VERBATIM">
   my $homer = NaturalPerson-&gt;new(
      firstName =&gt; 'Homer', name =&gt; 'Simpson' );
   $storage-&gt;insert( $homer );

   my $marge = NaturalPerson-&gt;new(
      firstName =&gt; 'Marge', name =&gt; 'Simpson',
      age =&gt; 34 );
   $storage-&gt;insert( $marge );

   $marge-&gt;{age} = 35;

   $homer-&gt;{partner} = $marge;

   $homer-&gt;{children} = Set::Object-&gt;new(
      NaturalPerson-&gt;new(
         firstName =&gt; 'Bart', name =&gt; 'Simpson' ),
      NaturalPerson-&gt;new(
         firstName =&gt; 'Lisa', name =&gt; 'Simpson' ),
      NaturalPerson-&gt;new(
         firstName =&gt; 'Maggie', name =&gt; 'Simpson' ) );

   $storage-&gt;update( $homer );
</pre>
<p class="POD_TEXT">
...Tangram automatically inserts the kids when their father is updated. OTOH, $marge will not be
automatically inserted nor updated; her age will remain '34' in persistent storage.
</p>
<h3 class="POD_HEAD2"><a name="id">id</a></h3>
<pre class="POD_VERBATIM">
   $id = $storage-&gt;id( $obj );
   @id = $storage-&gt;id( @obj );
</pre>
<p class="POD_TEXT">
Returns the IDs of the given objects. If an object is not persistent in storage yet, its
corresponding ID is undef().
</p>
<p class="POD_TEXT">
This method is valid in both the <u>scalar and list contexts</u> entry elsewhere in this document.
</p>
<h3 class="POD_HEAD2"><a name="load">load</a></h3>
<pre class="POD_VERBATIM">
   $obj = $storage-&gt;load( $id );
   @obj = $storage-&gt;load( @id );
</pre>
<p class="POD_TEXT">
Returns a list of objects given their IDs.
Dies if any ID has no corresponding persistent object in storage.
</p>
<p class="POD_TEXT">
This method is valid in both the <u>scalar and list contexts</u> entry elsewhere in this document.
</p>
<h3 class="POD_HEAD2"><a name="remote">remote</a></h3>
<pre class="POD_VERBATIM">
   @remote = $storage-&gt;remote( @classes );
</pre>
<p class="POD_TEXT">
Returns a list of the <a class="POD_LINK" href="../Tangram/Remote.html">Tangram::Remote</a> manpage objects of given classes.
This method is valid in both the <u>scalar and list contexts</u> entry elsewhere in this document.
</p>
<h3 class="POD_HEAD2"><a name="select">select</a></h3>
<pre class="POD_VERBATIM">
   @objs = select( $remote );

   @objs = select( $remote, $filter );

   @objs = select( $remote,
      opt1 =&gt; val1, opt2 =&gt; val2, ...);
</pre>
<p class="POD_TEXT">
Valid only in list context. Returns a list containing all the objects
that satisfy $filter.
</p>
<p class="POD_TEXT">
$remote can be either a Remote object of an array of Remote
objects. If it is a single Remote, a list of objects is returned. If
it is an array, a list of array of objects is returned.
</p>
<p class="POD_TEXT">
If one argument is passed, return all the objects of the given type.
</p>
<p class="POD_TEXT">
If two arguments are passed, the second argument must be a
Filter. select() returns the objects that satisfy $filter and are
type-compatible with the corresponding Remote.
</p>
<p class="POD_TEXT">
If more than two arguments are passed, the arguments after $remote<br>&nbsp;are treated as key/value pairs. Currently Tangram recognizes the following
directives:
</p>
<ul class="POD_LIST">
<li class="POD_ITEM"><a name="filter"><p>filter</p></a>
<li class="POD_ITEM"><a name="distinct"><p>distinct</p></a>
<li class="POD_ITEM"><a name="order"><p>order</p></a>
<li class="POD_ITEM"><a name="desc"><p>desc</p></a>
<li class="POD_ITEM"><a name="distinct1"><p>distinct</p></a>
</ul>
<p class="POD_TEXT">
<code>filter</code> specifies a Filter that can be used to restrict the result
set.
</p>
<p class="POD_TEXT">
<code>distinct</code> specifies that each object in the result set must be
unique (Tangram generates a SELECT DISTINCT).
</p>
<p class="POD_TEXT">
<code>order</code> THIS OPTION IS DEPRECATED!
</p>
<p class="POD_TEXT">
<code>desc</code> THIS OPTION IS DEPRECATED!
</p>
<p class="POD_TEXT">
<code>distinct</code> is a boolean; a true value specifies that the same object
should ocur only once in the result set.
</p>
<p class="POD_TEXT">
Valid only in list context.
</p>
<h3 class="POD_HEAD2"><a name="cursor">cursor</a></h3>
<pre class="POD_VERBATIM">
   $cursor = $storage-&gt;cursor( $remote );
   $cursor = $storage-&gt;cursor( $remote, $filter );
   $cursor = cursor( $remote,
      opt1 =&gt; val1, op2 =&gt; val2, ...);
</pre>
<p class="POD_TEXT">
Valid only in scalar context.
</p>
<p class="POD_TEXT">
Returns a Cursor on the objects that are type-compatible with $remote.
</p>
<p class="POD_TEXT">
If one argument is passed, the cursor returns all the objects of the given type.
</p>
<p class="POD_TEXT">
If two arguments are passed, the second argument must be a
Filter. The cursor returns the objects that satisfy $filter and are
type-compatible with the corresponding Remote.
</p>
<p class="POD_TEXT">
If more than two arguments are passed, the arguments after $remote
are treated as key/value pairs. Currently Tangram recognizes the following
directives:
</p>
<ul class="POD_LIST">
<li class="POD_ITEM"><a name="filter1"><p>filter</p></a>
<li class="POD_ITEM"><a name="order1"><p>order</p></a>
<li class="POD_ITEM"><a name="desc1"><p>desc</p></a>
<li class="POD_ITEM"><a name="distinct2"><p>distinct</p></a>
<li class="POD_ITEM"><a name="retrieve"><p>retrieve</p></a>
</ul>
<p class="POD_TEXT">
For options <code>filter</code>, <code>order</code>, <code>desc</code> and <code>distinct</code>, see <code>select</code>.
</p>
<p class="POD_TEXT">
Option <code>retrieve</code> is an array of Expr, to be retrieved in addition to
the object itself.
</p>
<h3 class="POD_HEAD2"><a name="erase">erase</a></h3>
<pre class="POD_VERBATIM">
   $storage-&gt;erase( @obj );
</pre>
<p class="POD_TEXT">
Removes objects from persistent storage. The objects remain present in transient storage.
</p>
<h3 class="POD_HEAD2"><a name="tx_start">tx_start</a></h3>
<pre class="POD_VERBATIM">
   $storage-&gt;tx_start();
</pre>
<p class="POD_TEXT">
Starts a new Tangram transaction.
</p>
<p class="POD_TEXT">
Tangram transactions can be nested.
</p>
<p class="POD_TEXT">
Tangram maintains a transaction nesting count for each storage and commits the operations only
when that count reaches zero. This scheme makes it easy for a function to collaborate with its caller
in the management of the the <u>internal connection</u> entry elsewhere in this document.
</p>
<p class="POD_TEXT">
Example:
</p>
<pre class="POD_VERBATIM">
   sub f
   {
      $storage-&gt;tx_start();
      $storage-&gt;update( $homer );
      $storage-&gt;tx_commit(); # or perhaps rollback()
   }

   sub g
   {
      $storage-&gt;tx_start();
      f();
      $storage-&gt;update( $marge );
      $storage-&gt;tx_commit(); # or perhaps rollback()
   }

   f(); # 1
   g(); # 2
</pre>
<p></p>
<p class="POD_TEXT">
In (1), f() commits the changes to $homer directly to the database.
</p>
<p class="POD_TEXT">
In (2), f() transparently reuses the transaction opened by g().\
Changes to both $homer and $marge are commited to the database when g() calls tx_commit().
</p>
<h3 class="POD_HEAD2"><a name="tx_commit">tx_commit</a></h3>
<pre class="POD_VERBATIM">
   $storage-&gt;tx_commit();
</pre>
<p class="POD_TEXT">
Commits the current Tangram transaction for this storage.
If the transaction being commited is the outermost transaction for this storage, the DBI
transaction is also commited.
</p>
<h3 class="POD_HEAD2"><a name="tx_rollback">tx_rollback</a></h3>
<pre class="POD_VERBATIM">
   $storage-&gt;tx_rollback();
</pre>
<p class="POD_TEXT">
Rolls back the current Tangram transaction for this storage.
If the transaction being rolled back is the outermost transaction for this storage, the DBI
transaction is also rolled back.
</p>
<h3 class="POD_HEAD2"><a name="tx_do">tx_do</a></h3>
<pre class="POD_VERBATIM">
   $storage-&gt;tx_do( sub { ... } );
</pre>
<p class="POD_TEXT">
Executes CODEREF under the protection of a Tangram transaction and
pass it @args in the argument list.
</p>
<p class="POD_TEXT">
Rolls back the transaction if CODEREF dies; in which case the
exception is re-thrown.
</p>
<p class="POD_TEXT">
Returns the results of CODEREF, either as a scalar or as a list
depending on the context in which tx_do was called.
</p>
<p class="POD_TEXT">
Example:
</p>
<pre class="POD_VERBATIM">
   $storage-&gt;tx_do(
      sub
      {
         $storage-&gt;update( $homer );
         # do things, die perhaps
         $storage-&gt;update( $marge );
      } );
</pre>
<p class="POD_TEXT">
Both $homer and $marge will be updated, or none will, depending on
whether the anonymous subroutine passed to tx_do() dies.
</p>
<h3 class="POD_HEAD2"><a name="unload">unload</a></h3>
<pre class="POD_VERBATIM">
   $storage-&gt;unload( @obj );
</pre>
<p class="POD_TEXT">
Drops references to persistent objects present in memory. @objs may
contain both objects and object ids. If @objs is empty, unloads all
the objects loaded by this storage.
</p>
<p class="POD_TEXT">
Storage keeps track of all the persistent objects that are present in
memory, in order to make sure that loading the same object twice
results in a single copy of the object.
</p>
<p class="POD_TEXT">
As a consequence, these objects will not be reclaimed by Perl's
automatic memory management mechanism until either disconnect() or
unload() is called.
</p>
<p class="POD_TEXT">
unload() should be called only when no other references exist to
persistent objects, otherwise the same object (in the database) may
end up having two copies in transient storage.
</p>
<h3 class="POD_HEAD2"><a name="disconnect">disconnect</a></h3>
<pre class="POD_VERBATIM">
   $storage-&gt;disconnect();
</pre>
<p class="POD_TEXT">
Disconnects from the database. Drops references to persistent
objects present in memory (see <code>unload</code>).
</p>
<hr>
<a class="POD_NAVLINK" href="#Pod_TOP_OF_PAGE">[Top]</a>
<!--#include virtual="/footer.html"-->