[% title = 'POD: Tangram::Sucks - what there is to be improved in Tangram' %]
[% INCLUDE header.tt %]


<p><a name="__index__"></a></p>
<!-- INDEX BEGIN -->

<ul>

	<li><a href="#name">NAME</a></li>
	<li><a href="#description">DESCRIPTION</a></li>
	<ul>

		<li><a href="#design_caveats">DESIGN CAVEATS</a></li>
		<li><a href="#hard_problems">HARD PROBLEMS</a></li>
		<li><a href="#missing_features">MISSING FEATURES</a></li>
	</ul>

</ul>
<!-- INDEX END -->

<hr />
<p>
</p>
<h1><a name="name">NAME</a></h1>
<p>Tangram::Sucks - what there is to be improved in Tangram</p>
<p>
</p>
<hr />
<h1><a name="description">DESCRIPTION</a></h1>
<p>Tangram has taken a concept very familiar to programmers in Java land
to its logical completion.</p>
<p>This document is an attempt by the coders of Tangram to summarise the
major problems that are inherant in the design, describe cases for
which the Tangram metaphor does not work well, and list long standing
TO-DO items.</p>
<p>
</p>
<h2><a name="design_caveats">DESIGN CAVEATS</a></h2>
<dl>
<dt><strong><a name="item_query_language_does_not_cover_all_sql_expressions"><strong>query language does not cover all SQL expressions</strong></a></strong><br />
</dt>
<dd>
Whilst there is no underlying fault with the query object metaphor
<em>per se</em>, there are currently lots of queries that cannot be
expressed in current versions of Tangram, and adding new parts to the
language is not easy.
</dd>
<p></p>
<dt><strong><a name="item_some_loss_of_encapsulation_with_queries"><strong>some loss of encapsulation with queries</strong></a></strong><br />
</dt>
<dd>
It could be said this is not a problem.  After all, adding properties
to a schema of an object is akin to declaring them as ``public''.
</dd>
<dd>
<p>Some people banter on about <em>data access patterns</em>, which the Tangram
schema represents.  But OO terms like that are usually treated as
buzzwords anyway.</p>
</dd>
<p></p></dl>
<p>
</p>
<h2><a name="hard_problems">HARD PROBLEMS</a></h2>
<dl>
<dt><strong><a name="item_partial_column_select"><strong>partial column select</strong></a></strong><br />
</dt>
<dd>
This optimisation has some serious dangers associated with it.
</dd>
<dd>
<p>It could either be</p>
</dd>
<p></p>
<dt><strong><a name="item_no_support_for_sql_update"><strong>no support for SQL UPDATE</strong></a></strong><br />
</dt>
<dd>
It may be possible to write a version of &$storage-E<gt;select()&gt;
that does this, which would look something like:
</dd>
<dd>
<pre>
  $storage-&gt;update
      ( $r_object,
        set =&gt; [ $r_object-&gt;{bar} == $r_object-&gt;{baz} + 2 ],
        filter =&gt; ($r_object-&gt;{frop} != undef)
      );</pre>
</dd>
<p></p>
<dt><strong><a name="item_no_explicit_support_for_re_2dorgs"><strong>no explicit support for re-orgs</strong></a></strong><br />
</dt>
<dd>
The situation where you have a large amount of schema reshaping to do,
with a complex enough data structure can turn into a fairly difficult
problem.
</dd>
<dd>
<p>It is possible to have two Tangram stores with different schema and
simply load objects from one and put them in the other - however the
on-demand autoloading combined with the automatic insertion of unknown
objects will result in the entire database being loaded into core if
it is sufficiently interlinked.</p>
</dd>
<p></p>
<dt><strong><a name="item_replace_sql_expression_core"><strong>replace SQL expression core</strong></a></strong><br />
</dt>
<dd>
The whole SQL expression core needs to be replaced with a SQL
abstraction module that is a little better planned.  For instance,
there should be placeholders used in a lot more places where the code
just sticks in an integer etc.
</dd>
<p></p>
<dt><strong><a name="item_support_for__60large_27_collections"><strong>support for `large' collections</strong></a></strong><br />
</dt>
<dd>
Where it is impractical or undesirable to load all of a collection
into memory, when you are adding a member and then updating the
container, it should be possible to
</dd>
<dd>
<p>This could actually be achieved with a new Tangram::Type.</p>
</dd>
<p></p></dl>
<p>
</p>
<h2><a name="missing_features">MISSING FEATURES</a></h2>
<dl>
<dt><strong><a name="item_concise_query_expressions"><strong>concise query expressions</strong></a></strong><br />
</dt>
<dd>
For simple selects, this is too long:
</dd>
<dd>
<pre>
  ...</pre>
</dd>
<p></p>
<dt><strong><a name="item_non_2did_joins"><strong>non-ID joins</strong></a></strong><br />
</dt>
<dt><strong><a name="item_tables_with_no_primary_key"><strong>tables with no primary key</strong></a></strong><br />
</dt>
<dt><strong><a name="item_tables_with_multi_2dcolumn_primary_keys"><strong>tables with multi-column primary keys</strong></a></strong><br />
</dt>
<dt><strong><a name="item_tables_with_auto_increment_keys"><strong>tables with auto_increment keys</strong></a></strong><br />
</dt>
<dt><strong><a name="item_tables_without_a__60type_27_column"><strong>tables without a `type' column</strong></a></strong><br />
</dt>
<dt><strong><a name="item_tables_with_custom__60type_27_columns"><strong>tables with custom `type' columns</strong></a></strong><br />
</dt>
<dt><strong><a name="item_implicit"><strong>tables with implicit (presence) `type' columns</strong></a></strong><br />
</dt>
<dt><strong><a name="item_fully_symmetric_relationships"><strong>fully symmetric relationships</strong></a></strong><br />
</dt>
<dd>
back-refs are read-only.
</dd>
<p></p>
<dt><strong><a name="item_bulk_inserts"><strong>bulk inserts</strong></a></strong><br />
</dt>
<dd>
Inserting lots of similar objects should be more efficient.  Right now
it generates a new STH for each object.
</dd>
<p></p>
<dt><strong><a name="item__60empty_subclass_27_schema_support"><strong>`empty subclass' schema support</strong></a></strong><br />
</dt>
<dd>
You should not need to explicitly add new classes to a schema if a
superclass of them is already in the schema.
</dd>
<p></p></dl>

[% INCLUDE footer.tt %]
