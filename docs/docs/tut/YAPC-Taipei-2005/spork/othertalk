
----
= Part 3. Tangram by Example

----
= Design Process

* process, not details

0 get requirements
0 produce specification
0 RAD prototype
0 review design &amp; spec.
0 finalise a set of features and release

----
= Identify Requirements

* Sit down, listen.  No, really listen.  You really care for your customer, right?
* Dream up a solution to meet their requirement, expand on ideas through dialog.
* Don't mention too many possible features that they won't need, but keep in mind

----
= Example: 1. Requirements

* Lexicon (phrase dictionary) for web site entries
* Support bulk translation via Babelfish/SysTrans
* Linguist web interface to edit automatic translation results
* Named string placeholders

----
= Example: 2. Make a plan, stan!

* Draw up "Functional Specification"
* Re-state the problem
* Introduce features in small achievable increments
* Use Handy Jismatic Features to make it look like you truly care about crafting a lavishly decorated and wonderfully radiant interior of custom made software heaven

----
= Functional Specification

* Scope
* Requirements & Discussion
* Definitions (ie, Data Model)
* Use Cases / mock-ups
{image: file:///home/samv/utsl/tangram-svk/website/docs/docs/tut/YAPC-Taipei-2005/funct-spec.png}

----
= Functional Specification: Data Model

UML!
{image: uml.png}

* design tools;
** Umbrello
** dia
** ArgoUML
** VT2

* Elements of UML:
** Class
** Attribute
** Method
** Association

----
= UML Associations

* Aggregation
* Composition
* Inheritance
{image: relationships.png}

----

= UML Design 1 – Lexicon Entry

* Use an inheritance system (similar to Locale::MakeText)
* Focus on good design of the objects, not how Storage works
{image: Lexicon-Entry.png}

----

= UML Design 2 – Lexicon Groups

* Entries are to be grouped by their “usage”
* Many to Many, not “composition”
{image: Lexicon-Groups+Lang.png}

----

= “Use Cases”

* Identify how data will be accessed, break down into major categories
* Note down and check that each use case is supported by data model
{image: UseCase.png}
+* Don't waste your time on diagrams of use cases; most of UML diagrams 
{image: BuUseCase.png}

----

= UML Design 3 – Use Cases

* *administration/maintenance website*
** Check automatic translation
** Browse groups by occurrance
* *Short Fire Scripts*
** per-script message catalog
* *Daemons & L10N'd (L7D?) Web Sites*
** per-template message catalog
* *Auto-translating client*

----

= Initial Design

{image: Lexicon-full.png}

----
= Example: 3. Sign-off Functional Specification

* Explain design in *clear terms* to customer
* This is something *you are sure* you can implement
* Ready to start implementing!

----
= UML to Tangram - approaches

* Start with Class::Tangram classes
* Start with an entire Tangram::Schema, using Class::Tangram::Generator
* Start with a T2::Schema generated by Visual T2

----

= Starting with Class::Tangram

* “Bottom-up” approach
* Write synopses
* build classes
* build tests
{code: lexicon-lang.pl}

----
= C::T to Tangram::Schema

* Simple to add Class::Tangram classes to a schema
* Class IDs, mapping can be changed – but be careful of sequence if altering column mapping
{code: lexicon-ct2t.pl}

----
= Starting with a Tangram::Schema

* Write complete schema first
* Use Class::Tangram::Generator to get “default” classes
* Can still provide .pm files to override default behaviour
* Or insert class methods as closures in the Tangram::Schema

----
= C::T::G example code

* “Lazy construct” all classes
* “Lazy implement” new classes

----

Starting with VT2 and a T2::Schema
Use web-based schema design tool “VT2”
currently fermenting
save “compiled” T2::Schema objects

----
= T2::Schema example code
Similar idea to using  C::T::Generator
Could be first piece of code for project!

----
= Extra Examples 1 – without C::T
Store existing, non-Class::Tangram classes
<ul><li>t/musicstore/ in Tangram 2.08 dist
<li>Fink schema
</ul></ul><br>

----
= Extra Examples 2 – alien tables
Lots of possible problems;
<ul><li>The ID conundrum
<li>Adapting for polymorphism and adding “type” columns
<li>non-ID joins and 3rd normal forms
<li>“clever” database hacks
But when it is possible, it's very handy!
Then can use Class::Tangram::Generator
</ul><br>

----
= UML to Tangram – the method
Convert persistent properies to Tangram::Scalar or Tangram::IDBIF columns
Inheritance to bases
</ul><br>

----
= UML to Tangram – example
<br>

----
= Step 4. Write Tests!
Deploy schema
Insert / retrieve objects
Start on the use cases
</ul><br>

